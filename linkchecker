#!/usr/bin/python3 -u
# Copyright (C) 2000-2014 Bastian Kleineidam
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""
Check HTML pages for broken links. This is the commandline
client. Run this file with the -h option to see how it's done.
"""

import sys
import os
import pprint

# installs _() and _n() gettext functions into global namespace
import linkcheck
from linkcheck import log, logconf
LOG_CMDLINE = linkcheck.LOG_CMDLINE

logconf.init_log_config()
# override argparse gettext method with the one from linkcheck.init_i18n()
# argparse._ = _
# now import the rest of the linkchecker gang
from linkcheck.arg_parser import ArgParser
from linkcheck.setup_config import setup_config
import linkcheck.configuration
import linkcheck.fileutil
from linkcheck.cmdline import aggregate_url, print_usage
from linkcheck.director import console, check_urls, get_aggregate
from linkcheck.strformat import stripurl

# optional modules
has_argcomplete = linkcheck.fileutil.has_module("argcomplete")
has_profile = linkcheck.fileutil.has_module("yappi")
has_meliae = linkcheck.fileutil.has_module("meliae")

# default profiling filename
_profile = "linkchecker.prof"
_username = None
_password = None


# instantiate option parser and configure options
argparser = ArgParser()

# build a config object for this check session
config = linkcheck.configuration.Configuration()
config.set_status_logger(console.StatusLogger())

# ================= auto completion =====================
if has_argcomplete:
    import argcomplete

    argcomplete.autocomplete(argparser)


def read_stdin_urls():
    """Read list of URLs, separated by white-space, from stdin."""
    num = 0
    while True:
        lines = sys.stdin.readlines(8 * 1024)
        if not lines:
            break
        for line in lines:
            for url in line.split():
                num += 1
                if num % 10000 == 0:
                    log.info(LOG_CMDLINE, "Read %d URLs from stdin", num)
                yield url


# read and parse command line options and arguments
options = argparser.parse_args()
# initialize logging
if options.debug:
    allowed_debugs = logconf.lognames.keys()
    for _name in options.debug:
        if _name not in allowed_debugs:
            print_usage(_("Invalid debug level %(level)r") % {"level": _name})
    logconf.set_debug(options.debug)
elif options.quiet:
    logconf.reset_loglevel()
log.debug(
    LOG_CMDLINE,
    _("Python %(version)s on %(platform)s")
    % {"version": sys.version, "platform": sys.platform},
)
# read configuration files
try:
    files = []
    if options.configfile:
        path = linkcheck.configuration.normpath(options.configfile)
        if os.path.isfile(path):
            files.append(path)
        else:
            log.warn(LOG_CMDLINE, _("Unreadable config file: %r"), options.configfile)
    config.read(files=files)
except linkcheck.LinkCheckerError as msg:
    # config error
    print_usage(str(msg))
linkcheck.drop_privileges()
# set up config object using options
setup_config(config, options)

# now sanitize the configuration
config.sanitize()

log.debug(LOG_CMDLINE, "configuration: %s", pprint.pformat(sorted(config.items())))

# prepare checking queue
aggregate = get_aggregate(config)
if options.trace:
    # enable thread tracing
    config["trace"] = True
    # start trace in mainthread
    import linkcheck.trace

    linkcheck.trace.trace_filter([r"^linkcheck"])
    linkcheck.trace.trace_on()
# add urls to queue
if options.stdin:
    for url in read_stdin_urls():
        aggregate_url(aggregate, url)
elif options.url:
    for url in options.url:
        aggregate_url(aggregate, stripurl(url))
else:
    log.warn(LOG_CMDLINE, _("no files or URLs given"))
# set up profiling
do_profile = False
if options.profile:
    if has_profile:
        if os.path.exists(_profile):
            print(
                _(
                    "Overwrite profiling file %(file)r?\n"
                    "Press Ctrl-C to cancel, RETURN to continue."
                )
                % {"file": _profile}
            )
            try:
                input()
            except KeyboardInterrupt:
                print("", _("Canceled."), file=sys.stderr, sep="\n")
                sys.exit(1)
        do_profile = True
    else:
        log.warn(
            LOG_CMDLINE,
            _(
                "The `yappi' Python module is not installed,"
                " therefore the --profile option is disabled."
            ),
        )

# finally, start checking
if do_profile:
    import yappi

    yappi.start()
    check_urls(aggregate)
    yappi.stop()
    yappi.get_func_stats().save(_profile)
else:
    check_urls(aggregate)
if config["debugmemory"]:
    import linkcheck.memoryutil

    if has_meliae:
        log.info(LOG_CMDLINE, _("Dumping memory statistics..."))
        filename = linkcheck.memoryutil.write_memory_dump()
        message = _("The memory dump has been written to `%(filename)s'.")
        log.info(LOG_CMDLINE, message % dict(filename=filename))
    else:
        log.warn(LOG_CMDLINE, linkcheck.memoryutil.MemoryDebugMsg)

stats = config["logger"].stats
# on internal errors, exit with status 2
if stats.internal_errors:
    sys.exit(2)
# on errors or printed warnings, exit with status 1
if stats.errors or (stats.warnings_printed and config["warnings"]):
    sys.exit(1)
